/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');
var state = require('@codemirror/state');
var view = require('@codemirror/view');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var obsidian__default = /*#__PURE__*/_interopDefaultLegacy(obsidian);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
		}
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var main = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, '__esModule', { value: true });



const DEFAULT_DAILY_NOTE_FORMAT = "YYYY-MM-DD";
const DEFAULT_WEEKLY_NOTE_FORMAT = "gggg-[W]ww";
const DEFAULT_MONTHLY_NOTE_FORMAT = "YYYY-MM";
const DEFAULT_QUARTERLY_NOTE_FORMAT = "YYYY-[Q]Q";
const DEFAULT_YEARLY_NOTE_FORMAT = "YYYY";

function shouldUsePeriodicNotesSettings(periodicity) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const periodicNotes = window.app.plugins.getPlugin("periodic-notes");
    return periodicNotes && periodicNotes.settings?.[periodicity]?.enabled;
}
/**
 * Read the user settings for the `daily-notes` plugin
 * to keep behavior of creating a new note in-sync.
 */
function getDailyNoteSettings() {
    try {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const { internalPlugins, plugins } = window.app;
        if (shouldUsePeriodicNotesSettings("daily")) {
            const { format, folder, template } = plugins.getPlugin("periodic-notes")?.settings?.daily || {};
            return {
                format: format || DEFAULT_DAILY_NOTE_FORMAT,
                folder: folder?.trim() || "",
                template: template?.trim() || "",
            };
        }
        const { folder, format, template } = internalPlugins.getPluginById("daily-notes")?.instance?.options || {};
        return {
            format: format || DEFAULT_DAILY_NOTE_FORMAT,
            folder: folder?.trim() || "",
            template: template?.trim() || "",
        };
    }
    catch (err) {
        console.info("No custom daily note settings found!", err);
    }
}
/**
 * Read the user settings for the `weekly-notes` plugin
 * to keep behavior of creating a new note in-sync.
 */
function getWeeklyNoteSettings() {
    try {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const pluginManager = window.app.plugins;
        const calendarSettings = pluginManager.getPlugin("calendar")?.options;
        const periodicNotesSettings = pluginManager.getPlugin("periodic-notes")?.settings?.weekly;
        if (shouldUsePeriodicNotesSettings("weekly")) {
            return {
                format: periodicNotesSettings.format || DEFAULT_WEEKLY_NOTE_FORMAT,
                folder: periodicNotesSettings.folder?.trim() || "",
                template: periodicNotesSettings.template?.trim() || "",
            };
        }
        const settings = calendarSettings || {};
        return {
            format: settings.weeklyNoteFormat || DEFAULT_WEEKLY_NOTE_FORMAT,
            folder: settings.weeklyNoteFolder?.trim() || "",
            template: settings.weeklyNoteTemplate?.trim() || "",
        };
    }
    catch (err) {
        console.info("No custom weekly note settings found!", err);
    }
}
/**
 * Read the user settings for the `periodic-notes` plugin
 * to keep behavior of creating a new note in-sync.
 */
function getMonthlyNoteSettings() {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const pluginManager = window.app.plugins;
    try {
        const settings = (shouldUsePeriodicNotesSettings("monthly") &&
            pluginManager.getPlugin("periodic-notes")?.settings?.monthly) ||
            {};
        return {
            format: settings.format || DEFAULT_MONTHLY_NOTE_FORMAT,
            folder: settings.folder?.trim() || "",
            template: settings.template?.trim() || "",
        };
    }
    catch (err) {
        console.info("No custom monthly note settings found!", err);
    }
}
/**
 * Read the user settings for the `periodic-notes` plugin
 * to keep behavior of creating a new note in-sync.
 */
function getQuarterlyNoteSettings() {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const pluginManager = window.app.plugins;
    try {
        const settings = (shouldUsePeriodicNotesSettings("quarterly") &&
            pluginManager.getPlugin("periodic-notes")?.settings?.quarterly) ||
            {};
        return {
            format: settings.format || DEFAULT_QUARTERLY_NOTE_FORMAT,
            folder: settings.folder?.trim() || "",
            template: settings.template?.trim() || "",
        };
    }
    catch (err) {
        console.info("No custom quarterly note settings found!", err);
    }
}
/**
 * Read the user settings for the `periodic-notes` plugin
 * to keep behavior of creating a new note in-sync.
 */
function getYearlyNoteSettings() {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const pluginManager = window.app.plugins;
    try {
        const settings = (shouldUsePeriodicNotesSettings("yearly") &&
            pluginManager.getPlugin("periodic-notes")?.settings?.yearly) ||
            {};
        return {
            format: settings.format || DEFAULT_YEARLY_NOTE_FORMAT,
            folder: settings.folder?.trim() || "",
            template: settings.template?.trim() || "",
        };
    }
    catch (err) {
        console.info("No custom yearly note settings found!", err);
    }
}

// Credit: @creationix/path.js
function join(...partSegments) {
    // Split the inputs into a list of path commands.
    let parts = [];
    for (let i = 0, l = partSegments.length; i < l; i++) {
        parts = parts.concat(partSegments[i].split("/"));
    }
    // Interpret the path commands to get the new resolved path.
    const newParts = [];
    for (let i = 0, l = parts.length; i < l; i++) {
        const part = parts[i];
        // Remove leading and trailing slashes
        // Also remove "." segments
        if (!part || part === ".")
            continue;
        // Push new path segments.
        else
            newParts.push(part);
    }
    // Preserve the initial slash if there was one.
    if (parts[0] === "")
        newParts.unshift("");
    // Turn back into a single string path.
    return newParts.join("/");
}
function basename(fullPath) {
    let base = fullPath.substring(fullPath.lastIndexOf("/") + 1);
    if (base.lastIndexOf(".") != -1)
        base = base.substring(0, base.lastIndexOf("."));
    return base;
}
async function ensureFolderExists(path) {
    const dirs = path.replace(/\\/g, "/").split("/");
    dirs.pop(); // remove basename
    if (dirs.length) {
        const dir = join(...dirs);
        if (!window.app.vault.getAbstractFileByPath(dir)) {
            await window.app.vault.createFolder(dir);
        }
    }
}
async function getNotePath(directory, filename) {
    if (!filename.endsWith(".md")) {
        filename += ".md";
    }
    const path = obsidian__default['default'].normalizePath(join(directory, filename));
    await ensureFolderExists(path);
    return path;
}
async function getTemplateInfo(template) {
    const { metadataCache, vault } = window.app;
    const templatePath = obsidian__default['default'].normalizePath(template);
    if (templatePath === "/") {
        return Promise.resolve(["", null]);
    }
    try {
        const templateFile = metadataCache.getFirstLinkpathDest(templatePath, "");
        const contents = await vault.cachedRead(templateFile);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const IFoldInfo = window.app.foldManager.load(templateFile);
        return [contents, IFoldInfo];
    }
    catch (err) {
        console.error(`Failed to read the daily note template '${templatePath}'`, err);
        new obsidian__default['default'].Notice("Failed to read the daily note template");
        return ["", null];
    }
}

/**
 * dateUID is a way of weekly identifying daily/weekly/monthly notes.
 * They are prefixed with the granularity to avoid ambiguity.
 */
function getDateUID(date, granularity = "day") {
    const ts = date.clone().startOf(granularity).format();
    return `${granularity}-${ts}`;
}
function removeEscapedCharacters(format) {
    return format.replace(/\[[^\]]*\]/g, ""); // remove everything within brackets
}
/**
 * XXX: When parsing dates that contain both week numbers and months,
 * Moment choses to ignore the week numbers. For the week dateUID, we
 * want the opposite behavior. Strip the MMM from the format to patch.
 */
function isFormatAmbiguous(format, granularity) {
    if (granularity === "week") {
        const cleanFormat = removeEscapedCharacters(format);
        return (/w{1,2}/i.test(cleanFormat) &&
            (/M{1,4}/.test(cleanFormat) || /D{1,4}/.test(cleanFormat)));
    }
    return false;
}
function getDateFromFile(file, granularity) {
    return getDateFromFilename(file.basename, granularity);
}
function getDateFromPath(path, granularity) {
    return getDateFromFilename(basename(path), granularity);
}
function getDateFromFilename(filename, granularity) {
    const getSettings = {
        day: getDailyNoteSettings,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings,
    };
    const format = getSettings[granularity]().format.split("/").pop();
    const noteDate = window.moment(filename, format, true);
    if (!noteDate.isValid()) {
        return null;
    }
    if (isFormatAmbiguous(format, granularity)) {
        if (granularity === "week") {
            const cleanFormat = removeEscapedCharacters(format);
            if (/w{1,2}/i.test(cleanFormat)) {
                return window.moment(filename, 
                // If format contains week, remove day & month formatting
                format.replace(/M{1,4}/g, "").replace(/D{1,4}/g, ""), false);
            }
        }
    }
    return noteDate;
}

class DailyNotesFolderMissingError extends Error {
}
/**
 * This function mimics the behavior of the daily-notes plugin
 * so it will replace {{date}}, {{title}}, and {{time}} with the
 * formatted timestamp.
 *
 * Note: it has an added bonus that it's not 'today' specific.
 */
async function createDailyNote(date) {
    const app = window.app;
    const { vault } = app;
    const moment = window.moment;
    const { template, format, folder } = getDailyNoteSettings();
    const [templateContents, IFoldInfo] = await getTemplateInfo(template);
    const filename = date.format(format);
    const normalizedPath = await getNotePath(folder, filename);
    try {
        const createdFile = await vault.create(normalizedPath, templateContents
            .replace(/{{\s*date\s*}}/gi, filename)
            .replace(/{{\s*time\s*}}/gi, moment().format("HH:mm"))
            .replace(/{{\s*title\s*}}/gi, filename)
            .replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
            const now = moment();
            const currentDate = date.clone().set({
                hour: now.get("hour"),
                minute: now.get("minute"),
                second: now.get("second"),
            });
            if (calc) {
                currentDate.add(parseInt(timeDelta, 10), unit);
            }
            if (momentFormat) {
                return currentDate.format(momentFormat.substring(1).trim());
            }
            return currentDate.format(format);
        })
            .replace(/{{\s*yesterday\s*}}/gi, date.clone().subtract(1, "day").format(format))
            .replace(/{{\s*tomorrow\s*}}/gi, date.clone().add(1, "d").format(format)));
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
    }
    catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian__default['default'].Notice("Unable to create new file.");
    }
}
function getDailyNote(date, dailyNotes) {
    return dailyNotes[getDateUID(date, "day")] ?? null;
}
function getAllDailyNotes() {
    /**
     * Find all daily notes in the daily note folder
     */
    const { vault } = window.app;
    const { folder } = getDailyNoteSettings();
    const dailyNotesFolder = vault.getAbstractFileByPath(obsidian__default['default'].normalizePath(folder));
    if (!dailyNotesFolder) {
        throw new DailyNotesFolderMissingError("Failed to find daily notes folder");
    }
    const dailyNotes = {};
    obsidian__default['default'].Vault.recurseChildren(dailyNotesFolder, (note) => {
        if (note instanceof obsidian__default['default'].TFile) {
            const date = getDateFromFile(note, "day");
            if (date) {
                const dateString = getDateUID(date, "day");
                dailyNotes[dateString] = note;
            }
        }
    });
    return dailyNotes;
}

class WeeklyNotesFolderMissingError extends Error {
}
function getDaysOfWeek() {
    const { moment } = window;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let weekStart = moment.localeData()._week.dow;
    const daysOfWeek = [
        "sunday",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday",
    ];
    while (weekStart) {
        daysOfWeek.push(daysOfWeek.shift());
        weekStart--;
    }
    return daysOfWeek;
}
function getDayOfWeekNumericalValue(dayOfWeekName) {
    return getDaysOfWeek().indexOf(dayOfWeekName.toLowerCase());
}
async function createWeeklyNote(date) {
    const { vault } = window.app;
    const { template, format, folder } = getWeeklyNoteSettings();
    const [templateContents, IFoldInfo] = await getTemplateInfo(template);
    const filename = date.format(format);
    const normalizedPath = await getNotePath(folder, filename);
    try {
        const createdFile = await vault.create(normalizedPath, templateContents
            .replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
            const now = window.moment();
            const currentDate = date.clone().set({
                hour: now.get("hour"),
                minute: now.get("minute"),
                second: now.get("second"),
            });
            if (calc) {
                currentDate.add(parseInt(timeDelta, 10), unit);
            }
            if (momentFormat) {
                return currentDate.format(momentFormat.substring(1).trim());
            }
            return currentDate.format(format);
        })
            .replace(/{{\s*title\s*}}/gi, filename)
            .replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm"))
            .replace(/{{\s*(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s*:(.*?)}}/gi, (_, dayOfWeek, momentFormat) => {
            const day = getDayOfWeekNumericalValue(dayOfWeek);
            return date.weekday(day).format(momentFormat.trim());
        }));
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
    }
    catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian__default['default'].Notice("Unable to create new file.");
    }
}
function getWeeklyNote(date, weeklyNotes) {
    return weeklyNotes[getDateUID(date, "week")] ?? null;
}
function getAllWeeklyNotes() {
    const weeklyNotes = {};
    if (!appHasWeeklyNotesPluginLoaded()) {
        return weeklyNotes;
    }
    const { vault } = window.app;
    const { folder } = getWeeklyNoteSettings();
    const weeklyNotesFolder = vault.getAbstractFileByPath(obsidian__default['default'].normalizePath(folder));
    if (!weeklyNotesFolder) {
        throw new WeeklyNotesFolderMissingError("Failed to find weekly notes folder");
    }
    obsidian__default['default'].Vault.recurseChildren(weeklyNotesFolder, (note) => {
        if (note instanceof obsidian__default['default'].TFile) {
            const date = getDateFromFile(note, "week");
            if (date) {
                const dateString = getDateUID(date, "week");
                weeklyNotes[dateString] = note;
            }
        }
    });
    return weeklyNotes;
}

class MonthlyNotesFolderMissingError extends Error {
}
/**
 * This function mimics the behavior of the daily-notes plugin
 * so it will replace {{date}}, {{title}}, and {{time}} with the
 * formatted timestamp.
 *
 * Note: it has an added bonus that it's not 'today' specific.
 */
async function createMonthlyNote(date) {
    const { vault } = window.app;
    const { template, format, folder } = getMonthlyNoteSettings();
    const [templateContents, IFoldInfo] = await getTemplateInfo(template);
    const filename = date.format(format);
    const normalizedPath = await getNotePath(folder, filename);
    try {
        const createdFile = await vault.create(normalizedPath, templateContents
            .replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
            const now = window.moment();
            const currentDate = date.clone().set({
                hour: now.get("hour"),
                minute: now.get("minute"),
                second: now.get("second"),
            });
            if (calc) {
                currentDate.add(parseInt(timeDelta, 10), unit);
            }
            if (momentFormat) {
                return currentDate.format(momentFormat.substring(1).trim());
            }
            return currentDate.format(format);
        })
            .replace(/{{\s*date\s*}}/gi, filename)
            .replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm"))
            .replace(/{{\s*title\s*}}/gi, filename));
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
    }
    catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian__default['default'].Notice("Unable to create new file.");
    }
}
function getMonthlyNote(date, monthlyNotes) {
    return monthlyNotes[getDateUID(date, "month")] ?? null;
}
function getAllMonthlyNotes() {
    const monthlyNotes = {};
    if (!appHasMonthlyNotesPluginLoaded()) {
        return monthlyNotes;
    }
    const { vault } = window.app;
    const { folder } = getMonthlyNoteSettings();
    const monthlyNotesFolder = vault.getAbstractFileByPath(obsidian__default['default'].normalizePath(folder));
    if (!monthlyNotesFolder) {
        throw new MonthlyNotesFolderMissingError("Failed to find monthly notes folder");
    }
    obsidian__default['default'].Vault.recurseChildren(monthlyNotesFolder, (note) => {
        if (note instanceof obsidian__default['default'].TFile) {
            const date = getDateFromFile(note, "month");
            if (date) {
                const dateString = getDateUID(date, "month");
                monthlyNotes[dateString] = note;
            }
        }
    });
    return monthlyNotes;
}

class QuarterlyNotesFolderMissingError extends Error {
}
/**
 * This function mimics the behavior of the daily-notes plugin
 * so it will replace {{date}}, {{title}}, and {{time}} with the
 * formatted timestamp.
 *
 * Note: it has an added bonus that it's not 'today' specific.
 */
async function createQuarterlyNote(date) {
    const { vault } = window.app;
    const { template, format, folder } = getQuarterlyNoteSettings();
    const [templateContents, IFoldInfo] = await getTemplateInfo(template);
    const filename = date.format(format);
    const normalizedPath = await getNotePath(folder, filename);
    try {
        const createdFile = await vault.create(normalizedPath, templateContents
            .replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
            const now = window.moment();
            const currentDate = date.clone().set({
                hour: now.get("hour"),
                minute: now.get("minute"),
                second: now.get("second"),
            });
            if (calc) {
                currentDate.add(parseInt(timeDelta, 10), unit);
            }
            if (momentFormat) {
                return currentDate.format(momentFormat.substring(1).trim());
            }
            return currentDate.format(format);
        })
            .replace(/{{\s*date\s*}}/gi, filename)
            .replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm"))
            .replace(/{{\s*title\s*}}/gi, filename));
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
    }
    catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian__default['default'].Notice("Unable to create new file.");
    }
}
function getQuarterlyNote(date, quarterly) {
    return quarterly[getDateUID(date, "quarter")] ?? null;
}
function getAllQuarterlyNotes() {
    const quarterly = {};
    if (!appHasQuarterlyNotesPluginLoaded()) {
        return quarterly;
    }
    const { vault } = window.app;
    const { folder } = getQuarterlyNoteSettings();
    const quarterlyFolder = vault.getAbstractFileByPath(obsidian__default['default'].normalizePath(folder));
    if (!quarterlyFolder) {
        throw new QuarterlyNotesFolderMissingError("Failed to find quarterly notes folder");
    }
    obsidian__default['default'].Vault.recurseChildren(quarterlyFolder, (note) => {
        if (note instanceof obsidian__default['default'].TFile) {
            const date = getDateFromFile(note, "quarter");
            if (date) {
                const dateString = getDateUID(date, "quarter");
                quarterly[dateString] = note;
            }
        }
    });
    return quarterly;
}

class YearlyNotesFolderMissingError extends Error {
}
/**
 * This function mimics the behavior of the daily-notes plugin
 * so it will replace {{date}}, {{title}}, and {{time}} with the
 * formatted timestamp.
 *
 * Note: it has an added bonus that it's not 'today' specific.
 */
async function createYearlyNote(date) {
    const { vault } = window.app;
    const { template, format, folder } = getYearlyNoteSettings();
    const [templateContents, IFoldInfo] = await getTemplateInfo(template);
    const filename = date.format(format);
    const normalizedPath = await getNotePath(folder, filename);
    try {
        const createdFile = await vault.create(normalizedPath, templateContents
            .replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
            const now = window.moment();
            const currentDate = date.clone().set({
                hour: now.get("hour"),
                minute: now.get("minute"),
                second: now.get("second"),
            });
            if (calc) {
                currentDate.add(parseInt(timeDelta, 10), unit);
            }
            if (momentFormat) {
                return currentDate.format(momentFormat.substring(1).trim());
            }
            return currentDate.format(format);
        })
            .replace(/{{\s*date\s*}}/gi, filename)
            .replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm"))
            .replace(/{{\s*title\s*}}/gi, filename));
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
    }
    catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian__default['default'].Notice("Unable to create new file.");
    }
}
function getYearlyNote(date, yearlyNotes) {
    return yearlyNotes[getDateUID(date, "year")] ?? null;
}
function getAllYearlyNotes() {
    const yearlyNotes = {};
    if (!appHasYearlyNotesPluginLoaded()) {
        return yearlyNotes;
    }
    const { vault } = window.app;
    const { folder } = getYearlyNoteSettings();
    const yearlyNotesFolder = vault.getAbstractFileByPath(obsidian__default['default'].normalizePath(folder));
    if (!yearlyNotesFolder) {
        throw new YearlyNotesFolderMissingError("Failed to find yearly notes folder");
    }
    obsidian__default['default'].Vault.recurseChildren(yearlyNotesFolder, (note) => {
        if (note instanceof obsidian__default['default'].TFile) {
            const date = getDateFromFile(note, "year");
            if (date) {
                const dateString = getDateUID(date, "year");
                yearlyNotes[dateString] = note;
            }
        }
    });
    return yearlyNotes;
}

function appHasDailyNotesPluginLoaded() {
    const { app } = window;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const dailyNotesPlugin = app.internalPlugins.plugins["daily-notes"];
    if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
        return true;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const periodicNotes = app.plugins.getPlugin("periodic-notes");
    return periodicNotes && periodicNotes.settings?.daily?.enabled;
}
/**
 * XXX: "Weekly Notes" live in either the Calendar plugin or the periodic-notes plugin.
 * Check both until the weekly notes feature is removed from the Calendar plugin.
 */
function appHasWeeklyNotesPluginLoaded() {
    const { app } = window;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (app.plugins.getPlugin("calendar")) {
        return true;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const periodicNotes = app.plugins.getPlugin("periodic-notes");
    return periodicNotes && periodicNotes.settings?.weekly?.enabled;
}
function appHasMonthlyNotesPluginLoaded() {
    const { app } = window;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const periodicNotes = app.plugins.getPlugin("periodic-notes");
    return periodicNotes && periodicNotes.settings?.monthly?.enabled;
}
function appHasQuarterlyNotesPluginLoaded() {
    const { app } = window;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const periodicNotes = app.plugins.getPlugin("periodic-notes");
    return periodicNotes && periodicNotes.settings?.quarterly?.enabled;
}
function appHasYearlyNotesPluginLoaded() {
    const { app } = window;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const periodicNotes = app.plugins.getPlugin("periodic-notes");
    return periodicNotes && periodicNotes.settings?.yearly?.enabled;
}
function getPeriodicNoteSettings(granularity) {
    const getSettings = {
        day: getDailyNoteSettings,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings,
    }[granularity];
    return getSettings();
}
function createPeriodicNote(granularity, date) {
    const createFn = {
        day: createDailyNote,
        month: createMonthlyNote,
        week: createWeeklyNote,
    };
    return createFn[granularity](date);
}

exports.DEFAULT_DAILY_NOTE_FORMAT = DEFAULT_DAILY_NOTE_FORMAT;
exports.DEFAULT_MONTHLY_NOTE_FORMAT = DEFAULT_MONTHLY_NOTE_FORMAT;
exports.DEFAULT_QUARTERLY_NOTE_FORMAT = DEFAULT_QUARTERLY_NOTE_FORMAT;
exports.DEFAULT_WEEKLY_NOTE_FORMAT = DEFAULT_WEEKLY_NOTE_FORMAT;
exports.DEFAULT_YEARLY_NOTE_FORMAT = DEFAULT_YEARLY_NOTE_FORMAT;
exports.appHasDailyNotesPluginLoaded = appHasDailyNotesPluginLoaded;
exports.appHasMonthlyNotesPluginLoaded = appHasMonthlyNotesPluginLoaded;
exports.appHasQuarterlyNotesPluginLoaded = appHasQuarterlyNotesPluginLoaded;
exports.appHasWeeklyNotesPluginLoaded = appHasWeeklyNotesPluginLoaded;
exports.appHasYearlyNotesPluginLoaded = appHasYearlyNotesPluginLoaded;
exports.createDailyNote = createDailyNote;
exports.createMonthlyNote = createMonthlyNote;
exports.createPeriodicNote = createPeriodicNote;
exports.createQuarterlyNote = createQuarterlyNote;
exports.createWeeklyNote = createWeeklyNote;
exports.createYearlyNote = createYearlyNote;
exports.getAllDailyNotes = getAllDailyNotes;
exports.getAllMonthlyNotes = getAllMonthlyNotes;
exports.getAllQuarterlyNotes = getAllQuarterlyNotes;
exports.getAllWeeklyNotes = getAllWeeklyNotes;
exports.getAllYearlyNotes = getAllYearlyNotes;
exports.getDailyNote = getDailyNote;
exports.getDailyNoteSettings = getDailyNoteSettings;
exports.getDateFromFile = getDateFromFile;
exports.getDateFromPath = getDateFromPath;
exports.getDateUID = getDateUID;
exports.getMonthlyNote = getMonthlyNote;
exports.getMonthlyNoteSettings = getMonthlyNoteSettings;
exports.getPeriodicNoteSettings = getPeriodicNoteSettings;
exports.getQuarterlyNote = getQuarterlyNote;
exports.getQuarterlyNoteSettings = getQuarterlyNoteSettings;
exports.getTemplateInfo = getTemplateInfo;
exports.getWeeklyNote = getWeeklyNote;
exports.getWeeklyNoteSettings = getWeeklyNoteSettings;
exports.getYearlyNote = getYearlyNote;
exports.getYearlyNoteSettings = getYearlyNoteSettings;
});

const ELEMENT_RE = /[\w-]+/g;
const ID_RE = /#[\w-]+/g;
const CLASS_RE = /\.[\w-]+/g;
const ATTR_RE = /\[[^\]]+\]/g;
const PSEUDO_CLASSES_RE = /\:(?!not)[\w-]+(\(.*\))?/g;
const PSEUDO_ELEMENTS_RE = /\:\:?(after|before|first-letter|first-line|selection)/g;
// convert an array-like object to array
function toArray(list) {
    return [].slice.call(list);
}
// handles extraction of `cssRules` as an `Array` from a stylesheet or something that behaves the same
function getSheetRules(win, stylesheet) {
    const sheet_media = stylesheet.media && stylesheet.media.mediaText;
    // if this sheet is disabled skip it
    if (stylesheet.disabled)
        return [];
    // if this sheet's media is specified and doesn't match the viewport then skip it
    if (sheet_media && sheet_media.length && !win.matchMedia(sheet_media).matches)
        return [];
    // get the style rules of this sheet
    try {
        return toArray(stylesheet.cssRules);
    }
    catch (_a) {
        return [];
    }
}
function _find(string, re) {
    const matches = string.match(re);
    return matches ? matches.length : 0;
}
// calculates the specificity of a given `selector`
function calculateScore(selector) {
    const score = [0, 0, 0];
    const parts = selector.split(" ");
    let part;
    let match;
    //TODO: clean the ':not' part since the last ELEMENT_RE will pick it up
    while (((part = parts.shift()), typeof part == "string")) {
        // find all pseudo-elements
        match = _find(part, PSEUDO_ELEMENTS_RE);
        score[2] += match;
        // and remove them
        match && (part = part.replace(PSEUDO_ELEMENTS_RE, ""));
        // find all pseudo-classes
        match = _find(part, PSEUDO_CLASSES_RE);
        score[1] += match;
        // and remove them
        match && (part = part.replace(PSEUDO_CLASSES_RE, ""));
        // find all attributes
        match = _find(part, ATTR_RE);
        score[1] += match;
        // and remove them
        match && (part = part.replace(ATTR_RE, ""));
        // find all IDs
        match = _find(part, ID_RE);
        score[0] += match;
        // and remove them
        match && (part = part.replace(ID_RE, ""));
        // find all classes
        match = _find(part, CLASS_RE);
        score[1] += match;
        // and remove them
        match && (part = part.replace(CLASS_RE, ""));
        // find all elements
        score[2] += _find(part, ELEMENT_RE);
    }
    return parseInt(score.join(""), 10);
}
// returns the heights possible specificity score an element can get from a give rule's selectorText
function getSpecificityScore(element, selectorText) {
    const selectors = selectorText.split(",");
    let selector;
    let score;
    let result = 0;
    while ((selector = selectors.shift())) {
        if (element.matches(selector)) {
            score = calculateScore(selector);
            result = score > result ? score : result;
        }
    }
    return result;
}
function sortBySpecificity(element, rules) {
    // comparing function that sorts CSSStyleRules according to specificity of their `selectorText`
    function compareSpecificity(a, b) {
        let aScore = getSpecificityScore(element, a.selectorText);
        let bScore = getSpecificityScore(element, b.selectorText);
        // If the styles come from app.css, they take a lower priority
        if (aScore === bScore) {
            if (a.parentStyleSheet.href)
                aScore -= 1;
            if (b.parentStyleSheet.href)
                bScore -= 1;
        }
        return aScore - bScore;
    }
    return rules.sort(compareSpecificity);
}
function getMatchedCSSRules(element) {
    const win = element.ownerDocument.defaultView;
    let styleSheets = toArray(element.ownerDocument.styleSheets);
    let sheet;
    let rules;
    let rule;
    let result = [];
    // assuming the browser hands us stylesheets in order of appearance
    // we iterate them from the beginning to follow proper cascade order
    while ((sheet = styleSheets.shift())) {
        // get the style rules of this sheet
        rules = getSheetRules(win, sheet);
        // loop the rules in order of appearance
        while ((rule = rules.shift())) {
            // if this is an @import rule
            if (rule.styleSheet) {
                // insert the imported stylesheet's rules at the beginning of this stylesheet's rules
                rules = getSheetRules(win, rule.styleSheet).concat(rules);
                // and skip this rule
                continue;
            }
            // if there's no stylesheet attribute BUT there IS a media attribute it's a media rule
            else if (rule.media) {
                // insert the contained rules of this media rule to the beginning of this stylesheet's rules
                rules = getSheetRules(win, rule).concat(rules);
                // and skip it
                continue;
            }
            // check if this element matches this rule's selector
            if (rule.selectorText && element.matches(rule.selectorText)) {
                // push the rule to the results set
                result.push(rule);
            }
        }
    }
    // sort according to specificity
    return sortBySpecificity(element, result);
}

const hideTitleField = 'embedded-title';

const updateTitle = state.StateEffect.define();
function shouldHide(cache, settings) {
    var _a, _b, _c, _d, _e;
    if (settings.hideOnMetadataField &&
        (cache === null || cache === void 0 ? void 0 : cache.frontmatter) &&
        cache.frontmatter[hideTitleField] === false) {
        return true;
    }
    if (settings.hideOnH1 && (cache === null || cache === void 0 ? void 0 : cache.sections)) {
        if (!cache.headings)
            return false;
        if (cache.sections &&
            ((_a = cache.sections[0]) === null || _a === void 0 ? void 0 : _a.type) === "heading" &&
            cache.headings &&
            ((_b = cache.headings[0]) === null || _b === void 0 ? void 0 : _b.level) === 1) {
            return true;
        }
        if (cache.sections &&
            ((_c = cache.sections[0]) === null || _c === void 0 ? void 0 : _c.type) === "yaml" &&
            ((_d = cache.sections[1]) === null || _d === void 0 ? void 0 : _d.type) === "heading" &&
            ((_e = cache.headings[0]) === null || _e === void 0 ? void 0 : _e.level) === 1) {
            return true;
        }
    }
    return false;
}
function getTitleForView(app, settings, view) {
    const frontmatterKey = settings.titleMetadataField;
    const file = view.file;
    let title = file === null || file === void 0 ? void 0 : file.basename;
    if (file) {
        const cache = app.metadataCache.getFileCache(file);
        if (shouldHide(cache, settings)) {
            return " ";
        }
        if (frontmatterKey &&
            (cache === null || cache === void 0 ? void 0 : cache.frontmatter) &&
            cache.frontmatter[frontmatterKey]) {
            return cache.frontmatter[frontmatterKey] || title || " ";
        }
    }
    if (file && settings.dailyNoteTitleFormat) {
        const date = main.getDateFromFile(file, "day");
        if (date) {
            return date.format(settings.dailyNoteTitleFormat);
        }
    }
    return title || " ";
}
function buildTitleDecoration(plugin, getSettings) {
    return [
        view.ViewPlugin.fromClass(class {
            constructor(view) {
                this.title = getTitleForView(plugin.app, getSettings(), view.state.field(obsidian.editorViewField));
                // This shouldn't happen, but just to be safe, remove any straggling titles
                view.contentDOM.parentElement.childNodes.forEach((node) => {
                    if (node instanceof HTMLElement &&
                        node.hasClass("embedded-note-title")) {
                        plugin.unobserveTitle(node);
                        node.remove();
                    }
                });
                this.header = createEl("h1", {
                    text: this.title,
                    cls: `cm-line embedded-note-title embedded-note-title__edit${this.title === " " ? " embedded-note-title__hidden" : ""}`,
                    attr: {
                        id: "title-cm6-" + Math.random().toString(36).substr(2, 9),
                    },
                });
                setTimeout(() => {
                    view.contentDOM.before(this.header);
                });
                plugin.observeTitle(this.header, (entry) => {
                    if (entry.borderBoxSize[0]) {
                        this.adjustGutter(entry.borderBoxSize[0].blockSize);
                    }
                    else {
                        this.adjustGutter(entry.contentRect.height);
                    }
                });
                this.adjustGutter(this.header.getBoundingClientRect().height);
            }
            adjustGutter(padding) {
                clearTimeout(this.debounce);
                this.debounce = window.setTimeout(() => {
                    var _a;
                    const dom = (_a = this.header) === null || _a === void 0 ? void 0 : _a.closest(".markdown-source-view");
                    if (!dom)
                        return;
                    let currentStyle = dom.getAttr("style");
                    if (!currentStyle) {
                        currentStyle = "";
                    }
                    if (currentStyle.contains("--embedded-note")) {
                        currentStyle = currentStyle.replace(/--embedded-note-title-height: \d+px;/g, "");
                    }
                    if (currentStyle && !currentStyle.endsWith(";")) {
                        currentStyle += `;--embedded-note-title-height: ${padding}px;`;
                    }
                    else {
                        currentStyle += `--embedded-note-title-height: ${padding}px;`;
                    }
                    dom.setAttribute("style", currentStyle);
                }, 10);
            }
            revertGutter() {
                const dom = this.header.closest(".markdown-source-view");
                let currentStyle = dom.getAttr("style");
                if (currentStyle && currentStyle.contains("--embedded-note")) {
                    currentStyle = currentStyle.replace(/--embedded-note-title-height: \d+px;/g, "");
                    dom.setAttribute("style", currentStyle);
                }
            }
            update(viewUpdate) {
                viewUpdate.transactions.forEach((tr) => {
                    for (let e of tr.effects) {
                        if (e.is(updateTitle)) {
                            const newTitle = getTitleForView(plugin.app, getSettings(), tr.state.field(obsidian.editorViewField));
                            if (this.title === newTitle) {
                                return;
                            }
                            this.title = newTitle;
                            this.header.setText(this.title);
                            if (this.title === " ") {
                                this.header.classList.add("embedded-note-title__hidden");
                            }
                            else {
                                this.header.classList.remove("embedded-note-title__hidden");
                            }
                        }
                    }
                });
            }
            destroy() {
                plugin.unobserveTitle(this.header);
                this.header.remove();
                this.header = null;
            }
        }),
    ];
}

// Split CSS margin and padding values like `0 auto`, `10px auto 0`, etc.
function getRightLeft(val) {
    if (/\s/.test(val)) {
        const vals = val.split(/\s+/g);
        if (vals.length === 2 || vals.length === 3) {
            return [vals[1], vals[1]];
        }
        if (vals.length === 4) {
            return [vals[1], vals[3]];
        }
    }
    return [val, val];
}
const keyMap = {
    width: "width",
    maxWidth: "max-width",
    margin: "margin",
    marginLeft: "margin-left",
    marginRight: "margin-right",
    padding: "padding",
    paddingLeft: "padding-left",
    paddingRight: "padding-right",
};
// Get the relevant style values from a reference element
function getRefSizing(el) {
    const rules = getMatchedCSSRules(el);
    const sizing = {};
    rules.forEach((r) => {
        const { width, maxWidth, margin, marginLeft, marginRight, padding, paddingLeft, paddingRight, } = r.style;
        if (width) {
            sizing.width = width;
        }
        if (maxWidth) {
            sizing.maxWidth = maxWidth;
        }
        if (margin) {
            const [mRight, mLeft] = getRightLeft(margin);
            sizing.marginLeft = mLeft;
            sizing.marginLeft = mRight;
        }
        if (marginLeft)
            sizing.marginLeft = marginLeft;
        if (marginRight)
            sizing.marginRight = marginRight;
        if (padding) {
            const [pRight, pLeft] = getRightLeft(padding);
            sizing.paddingLeft = pLeft;
            sizing.paddingLeft = pRight;
        }
        if (paddingLeft)
            sizing.paddingLeft = paddingLeft;
        if (paddingRight)
            sizing.paddingRight = paddingRight;
    });
    return sizing;
}
// Apply reference styles to a heading element
function applyRefStyles(heading, ref) {
    if (!ref)
        return;
    for (const key in ref) {
        const val = ref[key];
        if (val) {
            heading.style.setProperty(keyMap[key], val);
        }
    }
}
class PreviewHeadingsManager {
    constructor(getSettings) {
        this.headings = {};
        this.previewSizerRef = null;
        this.getSettings = getSettings;
    }
    getPreviewSizerStyles(doc) {
        const el = doc.getElementsByClassName("markdown-preview-sizer");
        if (el.length) {
            this.previewSizerRef = getRefSizing(el[0]);
        }
    }
    // Clean up headings once a pane has been closed or the plugin has been disabled
    removeHeading(id) {
        if (!this.headings[id])
            return;
        const doc = this.headings[id].leaf.view.containerEl.ownerDocument;
        const h1Preview = doc.getElementById(`${id}-preview`);
        if (h1Preview)
            h1Preview.remove();
        delete this.headings[id];
    }
    createHeading(id, leaf) {
        if (this.headings[id])
            return;
        const doc = leaf.view.containerEl.ownerDocument;
        const title = getTitleForView(leaf.view.app, this.getSettings(), leaf.view);
        const previewContent = leaf.view.containerEl.getElementsByClassName("markdown-preview-view");
        if (!this.previewSizerRef) {
            this.getPreviewSizerStyles(doc);
        }
        let previewEl;
        for (let i = 0, len = previewContent.length; i < len; i++) {
            if (previewContent[i].parentElement.parentElement.hasClass("view-content")) {
                previewEl = previewContent[i];
                break;
            }
        }
        if (previewEl) {
            // Create the preview heading
            const h1Preview = doc.createElement("h1");
            applyRefStyles(h1Preview, this.previewSizerRef);
            h1Preview.setText(title);
            h1Preview.id = `${id}-preview`;
            h1Preview.classList.add("embedded-note-title", "embedded-note-title__preview");
            if (title === "") {
                h1Preview.classList.add("embedded-note-title__hidden");
            }
            previewEl.prepend(h1Preview);
            this.headings[id] = { leaf };
        }
    }
    // Generate a unique ID for a leaf
    getLeafId(leaf) {
        return "title-" + Math.random().toString(36).substring(2, 9);
    }
    // Iterate through all leafs and generate headings if needed
    createHeadings(app) {
        const seen = {};
        app.workspace.getLeavesOfType("markdown").forEach((leaf) => {
            const id = this.getLeafId(leaf);
            if (id) {
                this.createHeading(id, leaf);
                seen[id] = true;
            }
        });
        Object.keys(this.headings).forEach((id) => {
            if (!seen[id]) {
                this.removeHeading(id);
            }
        });
    }
    cleanup() {
        this.previewSizerRef = null;
        Object.keys(this.headings).forEach((id) => {
            this.removeHeading(id);
        });
    }
}

class EmbeddedNoteTitlesPlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            document.body.classList.add("embedded-note-titles");
            yield this.loadSettings();
            this.addSettingTab(new EmbeddedNoteTitlesSettings(this.app, this));
            const getSettings = () => this.settings;
            this.app.workspace.trigger("parse-style-settings");
            this.previewHeadingsManager = new PreviewHeadingsManager(getSettings);
            this.isLegacyEditor = this.app.vault.getConfig("legacyEditor");
            if (!this.isLegacyEditor) {
                this.observedTitles = new Map();
                this.observer = new ResizeObserver((entries) => {
                    entries.forEach((entry) => {
                        if (this.observedTitles.has(entry.target)) {
                            this.observedTitles.get(entry.target)(entry);
                        }
                    });
                });
                this.registerEditorExtension(buildTitleDecoration(this, getSettings));
                const notifyFileChange = (file) => {
                    const markdownLeaves = this.app.workspace.getLeavesOfType("markdown");
                    markdownLeaves.forEach((leaf) => {
                        const view = leaf.view;
                        if (view.file === file) {
                            view.editor.cm.dispatch({
                                effects: updateTitle.of(),
                            });
                        }
                    });
                };
                this.registerEvent(this.app.vault.on("rename", notifyFileChange));
                this.registerEvent(this.app.metadataCache.on("changed", (file) => {
                    const frontmatterKey = this.settings.titleMetadataField;
                    const hideOnH1 = this.settings.hideOnH1;
                    if (frontmatterKey || hideOnH1) {
                        notifyFileChange(file);
                    }
                }));
            }
            this.registerEvent(this.app.metadataCache.on("changed", (file) => {
                const frontmatterKey = this.settings.titleMetadataField;
                const hideOnH1 = this.settings.hideOnH1;
                if (frontmatterKey || hideOnH1) {
                    const cache = this.app.metadataCache.getFileCache(file);
                    if (hideOnH1 ||
                        (frontmatterKey &&
                            (cache === null || cache === void 0 ? void 0 : cache.frontmatter) &&
                            cache.frontmatter[frontmatterKey])) {
                        setTimeout(() => {
                            this.previewHeadingsManager.createHeadings(this.app);
                        }, 0);
                    }
                }
            }));
            this.registerEvent(this.app.workspace.on("layout-change", () => {
                setTimeout(() => {
                    this.previewHeadingsManager.createHeadings(this.app);
                }, 0);
                if (!this.isLegacyEditor) {
                    setTimeout(() => {
                        this.observedTitles.forEach((_, el) => {
                            if (this.app.workspace
                                .getLeavesOfType("markdown")
                                .every((leaf) => !leaf.view.containerEl.find(`#${el.id}`))) {
                                this.unobserveTitle(el);
                                el.remove();
                            }
                        });
                    }, 100);
                }
            }));
            // Listen for CSS changes so we can recalculate heading styles
            this.registerEvent(this.app.workspace.on("css-change", () => {
                this.previewHeadingsManager.cleanup();
                setTimeout(() => {
                    this.previewHeadingsManager.createHeadings(this.app);
                }, 0);
            }));
            this.app.workspace.onLayoutReady(() => {
                // Trigger layout-change to ensure headings are created when the app loads
                this.app.workspace.trigger("layout-change");
            });
        });
    }
    onunload() {
        document.body.classList.remove("embedded-note-titles");
        this.previewHeadingsManager.cleanup();
        this.observer.disconnect();
        this.observedTitles.forEach((_, el) => {
            el.remove();
        });
        this.observedTitles.clear();
    }
    observeTitle(el, cb) {
        this.observedTitles.set(el, cb);
        this.observer.observe(el, {
            box: "border-box",
        });
    }
    unobserveTitle(el) {
        if (this.observedTitles.has(el)) {
            this.observedTitles.delete(el);
            this.observer.unobserve(el);
        }
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isLegacyEditor) {
                const markdownLeaves = this.app.workspace.getLeavesOfType("markdown");
                markdownLeaves.forEach((leaf) => {
                    const view = leaf.view;
                    view.editor.cm.dispatch({
                        effects: updateTitle.of(),
                    });
                });
            }
            this.previewHeadingsManager.cleanup();
            setTimeout(() => {
                this.previewHeadingsManager.createHeadings(this.app);
            }, 0);
            yield this.saveData(this.settings);
        });
    }
}
class EmbeddedNoteTitlesSettings extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    display() {
        let { containerEl } = this;
        containerEl.empty();
        new obsidian.Setting(containerEl)
            .setName("Frontmatter field as title")
            .setDesc("When a file contains this frontmatter field, it will be used as the embedded title")
            .addText((text) => {
            text
                .setValue(this.plugin.settings.titleMetadataField || "")
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.titleMetadataField = value;
                yield this.plugin.saveSettings();
            }));
        });
        new obsidian.Setting(containerEl)
            .setName("Hide embedded title when level 1 heading is present")
            .addToggle((toggle) => {
            toggle
                .setValue(this.plugin.settings.hideOnH1)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.hideOnH1 = value;
                yield this.plugin.saveSettings();
            }));
        });
        new obsidian.Setting(containerEl)
            .setName("Hide embedded title using metadata `embedded-title: false`")
            .addToggle((toggle) => {
            toggle
                .setValue(this.plugin.settings.hideOnMetadataField)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.hideOnMetadataField = value;
                yield this.plugin.saveSettings();
            }));
        });
        new obsidian.Setting(containerEl)
            .setName("Daily note title format")
            .then((setting) => {
            setting.addMomentFormat((mf) => {
                setting.descEl.appendChild(createFragment((frag) => {
                    frag.appendText("This format will be used when displaying titles of daily notes.");
                    frag.createEl("br");
                    frag.appendText("For more syntax, refer to ");
                    frag.createEl("a", {
                        text: "format reference",
                        href: "https://momentjs.com/docs/#/displaying/format/",
                    }, (a) => {
                        a.setAttr("target", "_blank");
                    });
                    frag.createEl("br");
                    frag.appendText("Your current syntax looks like this: ");
                    mf.setSampleEl(frag.createEl("b", { cls: "u-pop" }));
                    frag.createEl("br");
                }));
                const dailyNoteSettings = main.getDailyNoteSettings();
                const defaultFormat = dailyNoteSettings.format || "YYYY-MM-DD";
                mf.setPlaceholder(defaultFormat);
                mf.setDefaultFormat(defaultFormat);
                if (this.plugin.settings.dailyNoteTitleFormat) {
                    mf.setValue(this.plugin.settings.dailyNoteTitleFormat);
                }
                mf.onChange((value) => __awaiter(this, void 0, void 0, function* () {
                    this.plugin.settings.dailyNoteTitleFormat = value
                        ? value
                        : undefined;
                    yield this.plugin.saveSettings();
                }));
            });
        });
    }
}

module.exports = EmbeddedNoteTitlesPlugin;
